version 1.0 writed by HeSun

[TOC]



# 协议层次

## 七层：物联网淑惠试用

+ 应用层：HTTP，FTP，与用户交互
+ 表示层：数据压缩、数据加密。JPEG,GIF
+ 会话层：建立数据同步。RPC
+ 传输层：TCP/IP UDP
+ 网络层：选择路由
+ 数据链路层：将数据组装成帧
+ 物理层：数字信号到电信号

## 四层TCP/IP

+ 应用层
+ 传输层
+ 网络互联层
+ 网络接入层

# 应用层

## Http头部信息

+ 通用头部：客户端、服务端都可用的头部，如Date时间

+ 请求头部：客户端专有头部，客户端的要求，接受什么数据

+ 响应头部：告诉客户端信息，例如那种server

+ 实体头部：客户端、服务端都有对实体的说明，内容等

## KeepLive and 非KeepLive，对服务器性能有什么影响

### 非KeepLive每一次链接都要建立TCP三次握手，四次挥手，KeepLive让链接持久请求相应完成后，下一次依然用这个链接

## 长连接与短连接

+ 长连接用于客户端少，频繁数据交换
+ 短连接用于客户端多

## 怎么知道 HTTP 的报文长度

+ 对于短消息，可以使用响应头部中的content-length
+ 对于长消息，服务端不知道信息大小，分块传输，每个分块十六进制的长度值与数据，最后一个分块长度为0，表示结束

## HTTP方法

+ http1.0：
    get（读取数据）、head（获取报头）、post（提交数据处理请求）；

+ http1.1：（增加）
    put（增或换）、delete（删除）、options（返回支持方法）、connect（server代理访问）、trace（服务器返回接收数据）、patch（局部更新）

    

## Get与Post的区别*

+ GET将请求的数据放在URL后，不安全；POST将参数放在HTTP正文中，用于修改服务器数据
+ GET提交数据少，三次握手传数据；POST可以传送更多数据，post在真正接收数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据
+ GET是明文传输；POST可以加密
+ GET用于资源获取；POST修改写入数据

## GET长度限制：URL长度；POST一般无限制

## HTTP 与 HTTPs 的工作方式【建立连接的过程】

+ ### HTTP TCP连接，明文连接，80端口

+ ### HTTPS（加上传输加密与身份验证）

    + #### 客户端发送https请求443端口，发送支持的加密算法、密钥长度（生成随机数）

    + #### 服务端发送加密算法、其他加密算法套件、随机数（发送随机数）

    + #### 服务器使用证书、公钥

    + #### 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成

    + #### 客户端发送通过公钥加密的pre_master_secre（客户端生成）

    + #### 之后发送报文提示服务端在之后的报文采用会话密钥加密

    + #### 客户端发送 finish 报

    + #### 服务端同样发送报文，告诉采用会话密钥加密客户端进行确认

    + #### 服务端最后发送 finish 报文告诉客户端自己能够正确解密报文

## HTTP与HTTPS区别

+ HTTP明文传输；HTTPS密文传输
+ HTTPS需要数字认证机构申请证书
+ HTTPS443；HTTP80
+ HTTPS SSL四次握手

## HTTPS SSL四次握手

+ 客户端发送支持的加密算法、SSL版本、生成的随机数
+ 服务端发送采用的加密算法、数字验证证书、随机数、公钥、确认SSL版本
+ 客户端验证证书，确认密码套件、生成pre_master_secre、生成对称加密密钥、通过公钥加密pre_master_secre发送到服务端、之后采用会话密钥进行通信，客户端SSL完成，把之前所有数据发送服务端进行校验
+ 服务端接收pre_master_secre，生成密钥、返回之后采用会话密钥通信，把之前所有数据发送客户端进行校验

## HTTP不保存状态，如何保存用户状态

+ session：服务器建立键值对，将sessionID发送到客户端，客户端将其存在Cookie中，每次请求带上这个SessionId
+ Cooike：服务器发送响应数据在响应头设置set-cookie字段，储存客户端状态信息。每次客户请求带上cookie将状态信息储存在浏览器中

# http状态码

## 1xx:提示信息，表示目前是协议处理的中间状态，还需要后续的操作

## 2xx:成功，报文已经收到并被正确处理

+ 200：客户端请求成功
+ 206：范围请求成功

## 3xx:重定向，资源位置发生变化，需要客户端重新发送请求

+ 301：永久
+ 302：临时重定向

## 4xx：客户端错误，请求报文有误，服务器无法处理

+ 400：请求报文语法有误
+ 401：请求需要认证
+ 403：请求的资源禁止访问
+ 404：无法找到相应资源

## 5xx:服务器错误，服务器在处理请求时内部发生了错误

+ 500：服务端内部出错
+ 503：服务端正忙

## HTTP/1.1 和 HTTP/1.0 的区别

+ 1.1缓存策略更加灵活
+ 1.1默认长连接
+ 1.1增加的24个错误码状态响应码
+ 1.1头部有Range支持对某一资源的访问，而不是该资源的全部对象
+ 1.1添加了Host用于区分共享同一IP的虚拟主机

## HTTP/1.X 和 HTTP/2.0 的区别

+ HTTP 2.0服务器会主动推送一些信息储存在缓存中，本地从缓存中取资源
+ HTTP 2.0采用二进制进行传输（流ID以及优先级）
+ HTTP 2.0 的长连接通过流ID可以实现并行传输，1.x的长连接有同一TCP连接可以多个请求，但多个请求也是串行的
+ HTTP 2.0进行头部压缩，客户端和服务端去维护头部字段的表，每次头部只用传输字段对应的编号

## HTTP/3

+ 使用UDP在传输层传输数据，解决HTTP2中的TCP导致的队头阻塞，一个流出问题其他流收到影响

+ 使用QUIC（快速UDP网络连接），进行快速的网络连接1RTT即可连接，之后通过缓存取出连接0RTT即可完成连接
+ 使用QPACK进行头部压缩
+ QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立，不会因为IP改变重新连接，使用上下文的ID进行标识
+ ![image-20220304164413177](Picture\HTTP.png)

## DNS作用和原理：计算机和网络服务命名系统，用于TCP/IP网络；三个：根、顶级、权威

### 递归查询：一步一步问，再一个一个往回传，代为询问；迭代查询：查一个不行，别人告诉你去哪，你去查

## DNS更正确的答案是 DNS 既使用 TCP 又使用 UDP：数据长用TCP；数据端且频繁用UDP（DNS查询域名时）

## DNS劫持：通过篡改域名对应的IP进行劫持；方法防范：使用IP访问

+ 获取域名信息
+ 获得注册域名的EMAIL和密码
+ 修改注册信息
+ 使用EMail收发确认函



## socket套接字：套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。

+ 流套接字。TCP，面向连接、可靠的字节流传输
+ 数据包套接字。UDP，无连接
+ 原始套接字：用来传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包或操作系统无法处理的数据包）

## 	URI与URL都用于定义资源是什么，URL如何访问或定位到数据

## 为什么 fidder，charles 能抓到你的包【抓取数据包的过程】

### HTTP相当于透明人只做数据转发

### HTTPS对于客户端抓包工具为服务端，对于服务端为客户端；这就需要本地能够信任抓包工具提供的证书（也就是需要额外安装一个证书）

## 如果你访问一个网站很慢，怎么排查和解决:客户端网速，服务端丢包率、速度，网页设计、内容、结构

## 网页解析全过程

+ 用户输入网址
+ 使用DNS解析获得目标IP
+ TCP连接
+ 发送HTTP连接请求
+ 处理请求
+ 浏览器渲染
+ TCP断开

# 传输层（不全，因为较熟先写自己不会的或非常重要的）

## 第三次握手没有接收到，服务端重发ACK与SYN，客户端establshed，发送数据或者等2小时11分钟断开连接

## 为什么要进行三次握手？两次握手可以吗？*

+ 客户端知道服务端能接受自己数据；服务端不知道客户端能否接收自己数据
+ 无法同步序列号
+ 防止历史连接的建立
+ 服务端如果第二次握手信息没发到会导致大量资源浪费，多个无效链接一直等待数据

## CLOSE-WAIT*:用于服务端发送完剩余数据；TIME-WAIT：防止接收历史数据；保证连接正常关闭（客户端最后一次发送的ACK服务端没有接收到，无timewait，服务端重发的FIN后，客户端认为发生错误）

## 大量time_wait：占用端口、占用大量内存资源

## TIME_WAIT为什么2MSL：2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。<font color="whitblue">若服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文，再次向客户端发出 FIN 报文。如果客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文</font>

## 服务器可以设置 SO_REUSEADDR 套接字选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME_WAIT 状态时可以重用端口

## TCP与UDP区别

![image-20220304010407495](Picture\TCP与UDP.png)

## TCP中的定时器

![image-20220304010624481](Picture\定时器.png)

## TCP如何保证可靠性![image-20220304010926016](Picture\TCP保证可靠性.png)

## UDP不可靠：没有发送缓冲区，接收缓冲区满了后，无重传与流量控制、后面会丢弃

## <font color="red">TCP 的停止等待协议是什么</font>：该协议指的是发送方每发完一组数据后，直到收到接收方的确认信号才继续发送下一组数据

## Client:本地端口最多65535个，2^16；server：客户端IP数2^32 x 端口号2 ^ 16

## 拥塞控制

+ 慢启动：没接收一个ACK，cwnd + 1
+ 拥塞避免：接收一个ACK，增加1/cwnd(拥戴窗口)
+ 超时重传：thresh变为cwnd/2;cwnd = 1(拥塞发生)
+ 快恢复：cwnd = cwnd/2; thresh = cwnd ；cwnd = thresh+ 3(拥塞发生)

## TCP粘包和拆包问题：TCP是面向数据流传输的，没有消息保护边界，可能多个报文合在一起发（粘包），可能一个报文太大分开发（拆包）*

https://cloud.tencent.com/developer/article/1430021

![image-20220304105832330](Picture\TCP粘包拆包.png)

### TCP粘包和拆包问题产生原因

+ socket缓冲区与滑动窗口

+ MSS/MTU限制
    + 发送方发送数据时，当SO_SNDBUF中的数据量大于MSS时，操作系统会将数据进行拆分，使得每一部分都小于MSS，也形成了拆包。
+ Nagle算法
    + 为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据）。Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块

### 解决TCP粘包和拆包方法

+ 定长协议：将报文指定固定长度，不足用0补充；确定：浪费带宽
+ 特殊字符分隔符协议：在包尾部增加回车或者空格符等特殊字符进行分割 （如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并）
+ 变长协议：将消息区分为消息头和消息体
    + 发送方，发送数据之前，需要先获取需要发送内容的二进制字节大小（int），然后在需要发送的内容前面添加一个整数，表示消息体二进制字节的长度。
    + 接收方，在解析时，先读取内容长度Length，其值为实际消息体内容(Content)占用的字节数，之后必须读取到这么多字节的内容，才认为是一个完整的数据报文。

### 什么时间处理粘包问题

#### 当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题

## TCP 报文包含哪些信息

![image-20220304114111530](Picture\TCP报文段信息.png)

+ 源端口和目的端口号：它用于多路复用/分解来自或送往上层应用的数据，其和 IP 数据报中的源 IP 与目的 IP 地址一同确定一条 TCP 连接。

+ 序号和确认号字段：序号是本报文段发送的数据部分中第一个字节的编号，在 TCP 传送的流中，每一个字节一个序号。例如一个报文段的序号为 100，此报文段数据部分共有 100 个字节，则下一个报文段的序号为 200。序号确保了 TCP 传输的有序性。确认号，即 ACK，<font color="red">指明下一个想要收到的字节序号</font>，发送 ACK 时表明当前序号之前的所有数据已经正确接收。这两个字段的主要目的是保证数据可靠传输。

+ 首部长度：该字段指示了以 32 比特的字为单位的 TCP 的首部长度。其中固定字段长度为 20 字节，由于首部长度可能含有可选项内容，因此 TCP 报头的长度是不确定的，20 字节是 TCP 首部的最小长度。

+ 保留：为将来用于新的用途而保留。

+ 控制位：URG 表示紧急指针标志，该位为 1 时表示紧急指针有效，为 0 则忽略；ACK 为确认序号标志，即相应报文段包括一个对已被成功接收报文段的确认；PSH 为 push 标志，当该位为 1 时，则指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队； RST 为重置连接标志，当出现错误连接时，使用此标志来拒绝非法的请求；SYN 为同步序号，在连接的建立过程中使用，例如三次握手时，发送方发送 SYN 包表示请求建立连接；FIN 为 finish 标志，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。

+ 接收窗口：主要用于 TCP 流量控制。该字段用来告诉发送方其窗口（缓冲区）大小，以此控制发送速率，从而达到流量控制的目的。

+ 校验和：奇偶校验，此校验和是对整个 TCP 报文段，包括 TCP 头部和 数据部分。该校验和是一个端到端的校验和，由**发送端计算和存储，并由接收端进行验证，主要目的是检验数据** **是否发生改动**，若检测出差错，接收方会丢弃该 TCP 报文。

+ 紧急数据指针：紧急数据用于告知紧急数据所在的位置，在URG标志位为 1 时才有效。当紧急数据存在时，TCP 必须通知接收方的上层实体，接收方会对紧急模式采取相应的处理。

+ 选项：该字段一般为空，可根据首部长度进行推算。主要有以下作用：

    + TCP 连接初始化时，通信双方确认最大报文长度。

    +  在高速数据传输时，可使用该选项协商窗口扩大因子。

    +  作为时间戳时，提供一个 较为精准的 RTT。

    

## SYN攻击解决方法

+ 增⼤半连接队列，我们得知不能只单纯增⼤ tcp_max_syn_backlog 的值，还需⼀同增⼤ somaxconn 和 backlog，也就是增⼤全连接队列（somaxconn 和 backlog 之间的最⼩值）
    + 当 max_syn_backlog > min(somaxconn, backlog) max_qlen_log = min(somaxconn,backlog) * 2;
    + 当max_syn_backlog < min(somaxconn, backlog)  max_qlen_log = max_syn_backlog * 2;
+ 开tcp_syncookies ：计算cookie以SYN + ACK 中的序列号返回，客户端发送确认报文，建立连接
+ 减少SYM+ACK重传次数

## 服务端易受SYN攻击

### 大量SYN请求，每个服务端都要维护半连接状态，消耗资源，当资源占满就会停止响应正常请求

## 解决方法：

### 在服务端不开销资源，但失去超时重传

+ SYNCACHE: 使用hashtable，对每个连接通过哈希函数进行储存，维护一个哈希表，当桶满之前的会被取消
+ SYNCOOKIES：使用通过特定的算法将半开连接信息编码成序列号或者时间戳，用作服务端给客户端的消息编号，随 SYN-ACK 消息一同返回给连接发起方，直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源。

### 使用SYNProxy：在客户端和服务器之间部署一个代理服务器，类似于防火墙的作用。通过代理服务器与客户端进行建立连接的过程，之后代理服务器充当客户端将成功建立连接的客户端信息发送给服务器。这种方法基本不消耗服务器的资源，但是建立连接的时间变长了

# 网络层

## IP协议的定义与作用

+ 路由选择与寻址：源IP与目的IP，数据报的源主机和目的主机，在路由表选择合适的路径
+ 分组与重组：IP数据报在不同网络的数据报长度限制不同，所以，IP为每个数据包进行标识、储存分组组装信息，在不同网络中进行传输与目的主机后由目的主机完成重组工作

## IPV4 地址不够如何解决

+ DHCP：动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配IP地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的IP地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用。
+ NAT.在主机想要访问公网时转换为全球IP进行访问
+ IPV6

## 路由器的分组转发流程

## 路由器和交换机的区别*

+ 交换机：交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。
+ 路由器：路由器通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层

## ICMP

+ ICMP（Internet Control Message Protocol）是因特网控制报文协议，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。其主要的功能是验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）以及辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理）
+ ICMP 包头类型
    + 一类是用于诊断的查询消息，也就是「`查询报文类型`」
    + 另一类是通知出错原因的错误消息，也就是「`差错报文类型`」

### ICMP作用：网络层

+ 检验网络是否通畅
+ TRaceRoute：获得到达目的IP的最短路径
+ 辅助IP进行可靠传输，IP丢包告诉发送方丢包原因

## 两台电脑连起来后 ping 不通，你觉得可能存在哪些问题？

+ 网络、网卡
+ 是否在同一网段IP，子网掩码
+ 防火墙会阻挡ICMP
+ 看是否被第三方软件拦截
+ 两台设备间的网络延迟是否过大

## ARP 地址解析协议的原理和地址解析过程*：ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据 IP 地址获取目标物理地址的功能（MAC地址），它工作在第二层，是一个数据链路层协议

### 每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系

### 简单来说：ARP先在本地找，不行就广播找，找到返回ARP相应以及目标IP的MAC地址

## 网络地址转换 NAT：NAT（Network Address Translation），即网络地址转换，NAT网络地址转换，把内部私有IP地址翻译成公有IP地址，可以缓解IP地址不足的问题，而且还能隐藏和保护网络内部主机。

三种方式：

静态转换，一对一，一个私有对应一个公有。
动态转换，一对多，一个私有每次转换的公有不唯一。
端口多路复用，多对一，多个私有共享一个合法的外部IP，映射到了不同的端口上。

## 网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。

# 数据链路层

## MAC地址与IP地址

+ MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。
+ IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。

### 只有设备接入网络时才会分配IP地址，在设备还没IP地址时，通过MAC地址进行区分；IP与区域有关，通过区域IP->找到MAC地址

## 当采用静态或者动态转换时，由于一个私网 IP 地址对应一个公网地址，因此经过转换之后的公网 IP 地址是不同的；而采用端口复用方式的话，在一个子网中的所有地址都采用一个公网地址，但是使用的端口是不同的

## 数据链路层三个基本问题

+ 封装成帧：将网络层传下来的分组前后分别添加首部和尾部，这样就构成了帧。首部和尾部的一个重要作用是帧定界，也携带了一些必要的控制信息，对于每种数据链路层协议都规定了帧的数据部分的最大长度。
+ 透明传输：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部和尾部相同的内容， 那么帧的开始和结束的位置就会判断错，因此需要在数据部分中出现有歧义的内容前边插入转义字符，如果数据部分出现转义字符，则在该转义字符前再加一个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。
+ 差错检测：目前数据链路层广泛使用循环冗余检验（CRC）来检查数据传输过程中是否产生比特差错。

## CSMA/CD:载波侦听多路访问/冲突检测

+ 载波监听：表明信道处于忙碌状态，继续保持监听，直到信道空闲为止。如果发现信道是空闲的，就立即发送数据
+ 冲突检测：发生冲突，停止发送，之后退避让待发送节点一段时间后重发数据



![image-20220304013933035](C:\Users\SunHe\Desktop\sh面经\FaceScriptures\Picture\加密.png)

![image-20220322010307902](Picture\image-20220322010307902.png)

# MSL是一个报文段在网络中的最大生命周期

# RTT是客户到服务器往返所花时间

RTO 超时重传时间

# TTL:一个ip数据报可以经过的最大路由数

# MTU  (Maxitum Transmission Unit,最大传输单元)是**链路层**对一次可以发送的最[大数据](https://cloud.tencent.com/solution/bigdata?from=10680)的限制

MTU（1500）= 1518 - 18（数据链路层加的字节）

# MSS（Maxitum Segment Size,最大分段大小)是TCP报文中data部分的最大长度，是**传输层**对一次可以发送的最大数据的限制

MSS = 1500 - IP头（20或40）-TCP头（20）

# UDP保证可靠

## 缓存策略



## 