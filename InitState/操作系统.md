version 1.0 writed by SunHe

# 进程

## 进程定义：进程是进程实体的运行过程。是系统进行资源分配和调度的一个独立单位；进程实体：程序段、数据段、PCB![image-20220305143220736](Picture\进程PCB的组成.png)

## 进程与程序的区别

![image-20220305143622145](Picture\进程与程序的区别.png)

## 进程的状态*

![image-20220305145244085](Picture\进程状态.png)

![image-20220305145335466](Picture\进程状态总结.png)

## 进程控制*：实现进程状态的转换

### 使用原语进行，原语通过开关中断实现，原语程序不可中断，包括进程创建，进程终止，进程阻塞与唤醒（成对出现），进程的切换

## 进程通信\*\*

### 共享存储*

#### 申请共享区间，两个进程访问是互斥的，同步互斥工具

+ 基于数据结构的共享，比如只能放长度为10的数组
+ 基于存储区的共享
    + 在内存中画出一块共享储存区，数据形式、存放位置由进程控制<font color="red">实现方式</font>

#### 管道通信：内存中开开辟大小固定的缓冲区，管道是半双工通信，同一时间单向传输![image-20220305152753877](Picture\管道通信.png)

### 消息传递

![image-20220305152920926](Picture\消息传递.png)

### ![image-20220305152949594](Picture\进程通信的总结.png)

## 线程：程序执行的最小单位，基本的CPU执行单元

### 多线程模型：几个用户线程分配给几个内核级线程![image-20220305155144349](Picture\image-20220305155144349.png)

## 调度：当一堆任务要处理，由于资源有限无法同时处理，需要确定某种规则来决定处理这些任务的顺序![image-20220305160328702](Picture\处理机调度.png)

## 进程调度\*\*

![image-20220305160834555](Picture\image-20220305160834555.png)

### 进程调度方式

+ 非剥夺调度方式：只能在当前运行的进程主动放弃CPU时进行调度：先来先做，短作业，高相应优先
+ 剥夺调度方式：可由操作系统剥夺当前进程的CPU使用权。短作业（新的作业时间更短，先执行）

![image-20220305161242537](Picture\image-20220305161242537.png)

## 进程同步与进程互斥\*\*

### 进程同步：进程解决进程异步，按照一定顺序执行

### 进程异步：进程以各自不可预知的速度向前执行

## 进程互斥：同一时间只有一个进程访问该资源![image-20220305165211346](Picture\image-20220305165211346.png)

### 进程互斥的实现方法

+ 单标志法![image-20220305165701620](Picture\单标志法.png)

+ 双标志先检查法，出现两个资源同时访问统一组员 ，违背忙则等待
+ 双标志先检查法，两个可能都无法访问元素
+ Peterson![image-20220305170815827](Picture\image-20220305170815827.png)

## 进程互斥的硬件实现方法

## 信号量机制解决互斥与同步<font color="red">非常重要，前面可不看</font>

### 用户进程可以使用一对原语（wait  P、signal  V）对信号量进行操作，从而很方便的实现了进程互斥、进程同步

### 信号量其实就是一个变量，可以用一个信号量表示系统中某种资源的数量,可以是整数、

### 整形信号量：不满足让权等待![image-20220305172227703](Picture\image-20220305172227703.png)

### 记录型信号量![image-20220305172441806](Picture\image-20220305172441806.png)

![image-20220305172906514](Picture\image-20220305172906514.png)

![image-20220305173014047](Picture\image-20220305173014047.png)

## 用信号量实现互斥与同步\*\*

![image-20220305173403557](Picture\image-20220305173403557.png)

### 同步：通过前操作执行完++，资源+ 1，让下一个可以执行

![image-20220305173704962](Picture\image-20220305173704962.png)

### 进程的前驱关系

## 生产者消费者

![image-20220305175244581](C:\Users\SunHe\Desktop\sh面经\FaceScriptures\Picture\image-20220305175244581.png)

## 实现互斥的P操作一定要在实现同步的P操作之后

## 死锁\*\*:循环等待,进程间竞争资源而导致的各自进程阻塞的现象，而无法向前推进

+ 饥饿：当短进程优先算法，源源不断的短进程到来，长进程一直得不到处理及，而发生长进程”饥饿”

    

![image-20220305184321591](Picture\死锁发生的必要条件.png)

![image-20220305184439341](Picture\死锁时候.png)

![image-20220305184514074](Picture\死锁总结.png)

## 预防死锁

+ 将设备设为共享设备。破坏互斥条件
+ 破坏不剥夺条件
+ 破坏请求和保持条件
+ 破坏循环等待

## 避免死锁

### 安全序列：手里的资源必须能够完全满足一个进程

### 分配资源前判断是否会导致不安全序列

## <font color="red">管程</font>

# 内存

## 每个内存地址一个存储单元（1字节）

![image-20220305191613176](Picture\内存大小需要几个二进制位表示.png)

![image-20220305192313251](Picture\image-20220305192313251.png)

![image-20220305192850796](Picture\image-20220305192850796.png)

## 覆盖技术（不重要）：让不可能同时存在的模块共享一块内存，相互覆盖

## 交换技术![image-20220305194802383](C:\Users\SunHe\Desktop\sh面经\FaceScriptures\Picture\交换技术.png)

## 动态分区分配![image-20220306000208235](Picture\image-20220306000208235.png)

### 内存碎片![image-20220306000647429](Picture\image-20220306000647429.png)

## 基本分页存储管理：每个进程有个页表，保存到每个页框物理地址![image-20220306002224045](Picture\image-20220306002224045.png)

## 虚拟内存：通过 计算机逻辑扩充了内存，但物理没变

### ![image-20220306005514567](Picture\image-20220306005514567.png)

​	![image-20220306005732706](Picture\image-20220306005732706.png)

![image-20220306010006513](Picture\image-20220306010006513.png)

## 页面置换算法![image-20220306010108481](Picture\image-20220306010108481.png)

![image-20220306010318823](Picture\image-20220306010318823.png)

## 驻留集，请求分页给内存分配的管理快

# 随笔

## 操作系统中断，有用户态以及核心态，用户态->核心态只有一个中断

## CPU内外部中断信号-> 内外部中断信号

## 系统调用，系统的共享资源由操作系统统一管理，应用程序通过系统调用，系统自己协调调用

## 不可被中断的操作即原子操作